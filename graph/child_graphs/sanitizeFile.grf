<?xml version="1.0" encoding="UTF-8"?>
<Graph author="NickTaylor" created="Wed Oct 15 08:54:09 CEST 2025" guiVersion="7.2.0.8" id="1760520121684" licenseCode="CLCDSCLOVE24765514SP" name="sanitizeFile" showComponentDetails="true">
<Global>
<Metadata fileURL="${META_DIR}/sanitizationReport.fmt" id="Metadata8"/>
<Metadata id="Metadata3">
<Record fieldDelimiter="|" name="fileContent" recordDelimiter="\r\n" type="delimited">
<Field name="lineContent" type="string"/>
<Field name="fileURL" type="string"/>
</Record>
</Metadata>
<Metadata id="Metadata10">
<Record eofAsDelimiter="true" fieldDelimiter="ThereOnceWasABoyCalledEustaceClarenceScrubb" name="parseFile" previewAttachmentCharset="UTF-8" recordDelimiter="\r\n\\|\n\\|\r\\|\n\r" type="delimited">
<Field name="lineContent" type="string"/>
<Field auto_filling="source_name" name="fileURL" type="string"/>
</Record>
</Metadata>
<Metadata id="Metadata1">
<Record fieldDelimiter="\r\n\\|\n\\|\r\\|\n\r" name="properties" previewAttachment="${DATAIN_DIR}/sanitizeProperties.csv" previewAttachmentCharset="UTF-8" quoteChar="both" quotedStrings="false" skipSourceRows="0" type="delimited">
<Field name="property" type="string"/>
</Record>
</Metadata>
<Metadata id="Metadata5">
<Record fieldDelimiter="|" name="propertiesList" previewAttachmentCharset="UTF-8" recordDelimiter="\r\n" type="delimited">
<Field containerType="list" name="propertiesList" type="string"/>
</Record>
</Metadata>
<Metadata id="Metadata4">
<Record eofAsDelimiter="true" fieldDelimiter="|" name="sanitizedFile" previewAttachmentCharset="UTF-8" recordDelimiter="\r\n" type="delimited">
<Field delimiter="|" name="fileContent" type="string"/>
<Field delimiter="\r\n" name="fileURL" type="string"/>
</Record>
</Metadata>
<GraphParameters>
<GraphParameterFile fileURL="workspace.prm"/>
<GraphParameter name="SANDBOX_PATH" public="true" required="true" value="file:/C:/Users/NickTaylor/CloverDX/7_2_0/sandboxes/SandboxSanitizer/"/>
<GraphParameter name="SANDBOX_NAME" public="true">
<attr name="dynamicValue"><![CDATA[//#CTL2

function string getValue() {
	string sandbox = getParamValue("SANDBOX_PATH");
	
	// Remove final "/"
	if (endsWith(sandbox,"/")) {sandbox = left(sandbox,(length(sandbox)-1));}
	
	//Isolate only the sandbox name from the path
	integer sandboxIndex = 1 + lastIndexOf(sandbox,"/");
	sandbox = right(sandbox,length(sandbox)-sandboxIndex);
	
	
	return sandbox;
}
]]></attr>
</GraphParameter>
<GraphParameter name="FILE_URL" public="true"/>
<GraphParameter name="FILE_NAME" public="true"/>
<GraphParameter name="FILE_TYPE_PORT" public="true" value="0"/>
</GraphParameters>
<RichTextNote backgroundColor="9B59B6" folded="false" fontSize="medium" height="276" id="Note1" textColor="FFFFFF" width="275" x="225" y="400">
<attr name="text"><![CDATA[h3. Partition with different components for extensions
]]></attr>
</RichTextNote>
<RichTextNote backgroundColor="9B59B6" folded="false" fontSize="large" height="276" id="Note2" textColor="FFFFFF" width="501" x="2050" y="-50">
<attr name="text"><![CDATA[h3. Write Sanitized files to "Sanitized.zip" in data-tmp
]]></attr>
</RichTextNote>
<RichTextNote backgroundColor="3465A4" folded="false" fontSize="medium" height="826" id="Note3" textColor="FFFFFF" width="400" x="650" y="200">
<attr name="text"><![CDATA[h3. logic based on file type
]]></attr>
</RichTextNote>
<RichTextNote backgroundColor="9B59B6" folded="false" fontSize="medium" height="250" id="Note4" textColor="FFFFFF" width="401" x="1350" y="-25">
<attr name="text"><![CDATA[h3. prepare for writing
]]></attr>
</RichTextNote>
<RichTextNote backgroundColor="9B59B6" folded="false" fontSize="medium" height="200" id="Note0" textColor="FFFFFF" width="403" x="1350" y="575">
<attr name="text"><![CDATA[h3. Check if file is UNREDACTED and send to report]]></attr>
</RichTextNote>
<RichTextNote backgroundColor="9B59B6" folded="false" fontSize="medium" height="226" id="Note7" textColor="FFFFFF" width="526" x="1350" y="300">
<attr name="text"><![CDATA[h3. If File is REDACTED- send changes to report
]]></attr>
</RichTextNote>
<RichTextNote backgroundColor="9B59B6" folded="false" fontSize="medium" height="301" id="Note5" textColor="FFFFFF" width="377" x="2075" y="625">
<attr name="text"><![CDATA[h3. Write file changes to temp file]]></attr>
</RichTextNote>
<RichTextNote backgroundColor="9B59B6" folded="false" fontSize="medium" height="251" id="Note6" textColor="FFFFFF" width="550" x="-450" y="125">
<attr name="text"><![CDATA[h3. create list of properties to sanitize
]]></attr>
</RichTextNote>
<RichTextNote backgroundColor="9B59B6" folded="false" fontSize="medium" height="751" id="Note10" textColor="FFFFFF" width="525" x="1350" y="850">
<attr name="text"><![CDATA[h3. Write Warnings]]></attr>
</RichTextNote>
<RichTextNote backgroundColor="FF0000" folded="false" fontSize="large" height="803" id="Note8" textColor="FFFFFF" width="827" x="-400" y="850">
<attr name="text"><![CDATA[h1. DONT RUN ME!!


h3. This graph is meant to run as a child graph from RUN_ME.grf. It's not meant to run on it's own
]]></attr>
</RichTextNote>
<RichTextNote backgroundColor="FAF6D6" folded="false" fontSize="medium" height="350" id="Note9" textColor="444444" width="225" x="1075" y="825">
<attr name="text"><![CDATA[h3. currently Wrangler files are not sanitized but they could be in the next version]]></attr>
</RichTextNote>
<Dictionary>
<Entry input="true" name="connectionName" output="true" type="string"/>
<Entry input="true" name="fileURL" output="true" type="string"/>
<Entry dictval.value="UNREDACTED" input="true" name="status" output="true" type="string"/>
</Dictionary>
</Global>
<Phase number="0">
<Node dedupKey="property(a)" guiName="Dedup" guiX="-230" guiY="225" id="DEDUP1" sorted="false" type="DEDUP"/>
<Node guiName="error reading file" guiX="1410" guiY="1190" id="ERROR_READING_FILE" type="REFORMAT">
<attr name="transform"><![CDATA[//#CTL2

// Transforms input record into output record.
function integer transform() {
	
	//If this graph reads itself it will cause an error so this logic will keep it from writing to the warnings about itself
	if(contains($in.0.errorMessage,"ThereOnceWasABoyCalledEustaceClarenceScrubb") and getParamValue("FILE_NAME")=="sanitizeFile.grf"){return SKIP;} 
	
	
	
	//fileURL to Sanitized.zip and dictionary output
	string url = replace(getParamValue("FILE_URL"),"\\\\","/");
	string[] urlList = split(url,getParamValue("SANDBOX_NAME")+ "/");
	url = urlList[length(urlList)-1];
	string fileURL = getParamValue("SANDBOX_NAME") + "/" + url;
	$out.0.file_url = fileURL;
	
	
	$out.0.sandbox = getParamValue("SANDBOX_NAME");
	$out.0.file_name = getParamValue("FILE_NAME");
	dictionary.status = "REQUIRES ATTENTION - FILE ERROR";
	$out.0.status = dictionary.status;
	$out.0.message = "Error Parsing this file: "+  $in.0.errorMessage;

	return ALL;
}

// Called during component initialization.
// function boolean init() {}

// Called during each graph run before the transform is executed. May be used to allocate and initialize resources
// required by the transform. All resources allocated within this method should be released
// by the postExecute() method.
// function void preExecute() {}

// Called only if transform() throws an exception.
// function integer transformOnError(string errorMessage, string stackTrace) {}

// Called during each graph run after the entire transform was executed. Should be used to free any resources
// allocated within the preExecute() method.
// function void postExecute() {}

// Called to return a user-defined error message when an error occurs.
// function string getMessage() {}
]]></attr>
</Node>
<Node guiName="properties List" guiX="-80" guiY="225" id="PROPERTIES_LIST" type="DENORMALIZER">
<attr name="denormalize"><![CDATA[//#CTL2
// This transformation defines the way in which multiple input records 
// (with the same key) are denormalized into one output record. 

// This function is called for each input record from a group of records
// with the same key.
string[] propertiesList;
function integer append() {
	append(propertiesList,$in.0.property);
	return OK;
}

// This function is called once after the append() function was called for all records
// of a group of input records defined by the key.
// It creates a single output record for the whole group.
function integer transform() {
	$out.0.propertiesList = propertiesList;
	return OK;
}

// Called during component initialization.
// function boolean init() {}

// Called during each graph run before the transform is executed. May be used to allocate and initialize resources
// required by the transform. All resources allocated within this method should be released
// by the postExecute() method.
// function void preExecute() {}

// Called only if append() throws an exception.
// function integer appendOnError(string errorMessage, string stackTrace) {
// }

// Called only if transform() throws an exception.
//function integer transformOnError(string errorMessage, string stackTrace) {
//}

// Called after transform() to return the resources that have been used to their initial state
// so that next group of records with different key may be parsed.
// function void clean() {}

// Called during each graph run after the entire transform was executed. Should be used to free any resources
// allocated within the preExecute() method.
// function void postExecute() {}

// Called to return a user-defined error message when an error occurs.
// function string getMessage() {}
]]></attr>
</Node>
<Node dataPolicy="controlled" fileURL="${FILE_URL}" guiName="read file content" guiX="-405" guiY="525" id="READ_FILE_CONTENT" type="FLAT_FILE_READER" verbose="true"/>
<Node guiName="reformat fileURL" guiX="-180" guiY="525" id="REFORMAT_FILE_URL" type="REFORMAT">
<attr name="transform"><![CDATA[//#CTL2

// Transforms input record into output record.
function integer transform() {
	//fileContent to Sanitized.zip
	$out.0.lineContent = $in.0.lineContent;
	
	//fileURL to Sanitized.zip and dictionary output
	string url = replace(getParamValue("FILE_URL"),"\\\\","/");
	string[] urlList = split(url,getParamValue("SANDBOX_NAME")+ "/");
	dictionary.fileURL = concat(getParamValue("SANDBOX_NAME"), "/", urlList[length(urlList)-1]);
	$out.0.fileURL = dictionary.fileURL;
	
	return ALL;
}
]]></attr>
</Node>
<Node fileURL="${DATAIN_DIR}/sanitizeProperties.csv" guiName="sanitizeProperties.csv" guiX="-430" guiY="225" id="SANITIZE_PROPERTIES_CSV" type="FLAT_FILE_READER"/>
<Edge fromNode="DEDUP1:0" guiBendpoints="" guiRouter="Manhattan" id="Edge32" inPort="Port 0 (in)" outPort="Port 0 (unique)" toNode="PROPERTIES_LIST:0"/>
<Edge fromNode="ERROR_READING_FILE:0" guiBendpoints="" guiRouter="Manhattan" id="Edge13" inPort="Port 4 (in)" outPort="Port 0 (out)" toNode="SIMPLE_GATHER2:4"/>
<Edge fromNode="PROPERTIES_LIST:0" guiBendpoints="" guiRouter="Manhattan" id="Edge33" inPort="Port 1 (slave)" metadata="Metadata5" outPort="Port 0 (out)" toNode="CROSS_JOIN:1"/>
<Edge fromNode="READ_FILE_CONTENT:0" guiBendpoints="" guiRouter="Manhattan" id="Edge5" inPort="Port 0 (in)" metadata="Metadata10" outPort="Port 0 (output)" toNode="REFORMAT_FILE_URL:0"/>
<Edge fromNode="READ_FILE_CONTENT:1" guiBendpoints="" guiRouter="Manhattan" id="Edge12" inPort="Port 0 (in)" outPort="Port 1 (logs)" toNode="ERROR_READING_FILE:0"/>
<Edge fromNode="REFORMAT_FILE_URL:0" guiBendpoints="" guiRouter="Manhattan" id="Edge1" inPort="Port 0 (master)" metadata="Metadata3" outPort="Port 0 (out)" toNode="CROSS_JOIN:0"/>
<Edge fromNode="SANITIZE_PROPERTIES_CSV:0" guiBendpoints="" guiRouter="Manhattan" id="Edge31" inPort="Port 0 (in)" metadata="Metadata1" outPort="Port 0 (output)" toNode="DEDUP1:0"/>
</Phase>
<Phase number="1">
<Node guiName="CrossJoin" guiX="70" guiY="500" id="CROSS_JOIN" type="CROSS_JOIN">
<attr name="transform"><![CDATA[//#CTL2

function integer transform() {
	$out.0.lineContent = $in.0.lineContent;
	$out.0.fileURL = $in.0.fileURL;
	$out.0.propertiesList = $in.1.propertiesList;

	return ALL;
}
]]></attr>
</Node>
<Edge fromNode="CROSS_JOIN:0" guiBendpoints="" guiRouter="Manhattan" id="Edge34" inPort="Port 0 (in)" outPort="Port 0 (out)" toNode="PARTITION:0"/>
</Phase>
<Phase number="2">
<Node guiName="add # to help earlier Clover versions" guiX="2070" guiY="50" id="ADD_TO_HELP_EARLIER_CLOVER_VERSIONS" type="REFORMAT">
<attr name="transform"><![CDATA[//#CTL2

// Transforms input record into output record.
function integer transform() {
	$out.0.fileContent = $in.0.fileContent;
	$out.0.fileURL = "#"+$in.0.fileURL;

	return ALL;
}

// Called during component initialization.
// function boolean init() {}

// Called during each graph run before the transform is executed. May be used to allocate and initialize resources
// required by the transform. All resources allocated within this method should be released
// by the postExecute() method.
// function void preExecute() {}

// Called only if transform() throws an exception.
// function integer transformOnError(string errorMessage, string stackTrace) {}

// Called during each graph run after the entire transform was executed. Should be used to free any resources
// allocated within the preExecute() method.
// function void postExecute() {}

// Called to return a user-defined error message when an error occurs.
// function string getMessage() {}
]]></attr>
</Node>
<Node guiName="check for JNDI" guiX="1395" guiY="1375" id="CHECK_FOR_JNDI" type="EXT_FILTER">
<attr name="filterExpression"><![CDATA[//#CTL2
contains(lowerCase($in.0.fileContent),"jndiname=")]]></attr>
</Node>
<Node guiName="combine cfg properties" guiX="845" guiY="475" id="COMBINE_CFG_PROPERTIES" key="file_url(a)" type="DENORMALIZER">
<attr name="denormalize"><![CDATA[//#CTL2
// This transformation defines the way in which multiple input records 
// (with the same key) are denormalized into one output record. 

// This function is called for each input record from a group of records
// with the same key.
string[] properties;
string[] type;
string[] name;
function integer append() {
	if($in.0.redacted_properties != null and !in($in.0.redacted_properties,properties)){append(properties,$in.0.redacted_properties);}
	if($in.0.name != null){append(name,$in.0.name);}
	if($in.0.type != null){append(type,$in.0.type);}
	return OK;
}

// This function is called once after the append() function was called for all records
// of a group of input records defined by the key.
// It creates a single output record for the whole group.
function integer transform() {
	$out.0.sandbox = getParamValue("SANDBOX_NAME");
	$out.0.file_url = $in.0.file_url;
	$out.0.file_name = getParamValue("FILE_NAME");
	$out.0.status = dictionary.status;
	if(length(type) > 0){$out.0.type = type[0];}
	if(length(name) >0){$out.0.name = dictionary.connectionName;}
	if(length(properties) > 0){$out.0.redacted_properties = join(",",properties);}
	if($out.0.status == "REDACTED") {$out.0.message = "Potentially sensitive data";}
	return OK;
}

// Called during component initialization.
// function boolean init() {}

// Called during each graph run before the transform is executed. May be used to allocate and initialize resources
// required by the transform. All resources allocated within this method should be released
// by the postExecute() method.
// function void preExecute() {}

// Called only if append() throws an exception.
// function integer appendOnError(string errorMessage, string stackTrace) {
// }

// Called only if transform() throws an exception.
//function integer transformOnError(string errorMessage, string stackTrace) {
//}

// Called after transform() to return the resources that have been used to their initial state
// so that next group of records with different key may be parsed.
// function void clean() {}

// Called during each graph run after the entire transform was executed. Should be used to free any resources
// allocated within the preExecute() method.
// function void postExecute() {}

// Called to return a user-defined error message when an error occurs.
// function string getMessage() {}
]]></attr>
</Node>
<Node guiName="files not sanitized" guiX="670" guiY="875" id="FILES_NOT_SANITIZED1" type="REFORMAT">
<attr name="transform"><![CDATA[//#CTL2

// Transforms input record into output record.
function integer transform() {
	$out.0.fileContent = nvl($in.0.lineContent,"");
	$out.0.fileURL = $in.0.fileURL;
	$out.1.file_url = $in.0.fileURL;
	$out.1.sandbox = getParamValue("SANDBOX_NAME");
	$out.1.file_name = getParamValue("FILE_NAME");
	$out.1.message = "This file type can't be redacted automatically and might contain sensitive data. Please check the file and manually remove content you don't want to share.";
	dictionary.status = "REQUIRES ATTENTION - FILE NOT SUPPORTED";
	$out.1.status = dictionary.status;
	return ALL;
}

// Called during component initialization.
// function boolean init() {}

// Called during each graph run before the transform is executed. May be used to allocate and initialize resources
// required by the transform. All resources allocated within this method should be released
// by the postExecute() method.
// function void preExecute() {}

// Called only if transform() throws an exception.
// function integer transformOnError(string errorMessage, string stackTrace) {}

// Called during each graph run after the entire transform was executed. Should be used to free any resources
// allocated within the preExecute() method.
// function void postExecute() {}

// Called to return a user-defined error message when an error occurs.
// function string getMessage() {}
]]></attr>
</Node>
<Node guiName="general error message" guiX="1570" guiY="875" id="GENERAL_ERROR_MESSAGE" type="REFORMAT">
<attr name="transform"><![CDATA[//#CTL2

// Transforms input record into output record.
function integer transform() {
	$out.0.file_url = $in.0.file_url;
	$out.0.sandbox = $in.0.sandbox;
	$out.0.file_name = $in.0.file_name;
	dictionary.status = "REQUIRES ATTENTION - SANITIZATION ERROR";
	$out.0.status = dictionary.status;
	$out.0.message = "This file could not be sanitized. Check the output file for sensitive data before uploading";

	return ALL;
}

// Called during component initialization.
// function boolean init() {}

// Called during each graph run before the transform is executed. May be used to allocate and initialize resources
// required by the transform. All resources allocated within this method should be released
// by the postExecute() method.
// function void preExecute() {}

// Called only if transform() throws an exception.
// function integer transformOnError(string errorMessage, string stackTrace) {}

// Called during each graph run after the entire transform was executed. Should be used to free any resources
// allocated within the preExecute() method.
// function void postExecute() {}

// Called to return a user-defined error message when an error occurs.
// function string getMessage() {}
]]></attr>
</Node>
<Node guiName="ignore .fmt and .wjob" guiX="1420" guiY="1025" id="IGNORE_FMT_AND_WJOB" type="EXT_FILTER">
<attr name="filterExpression"><![CDATA[//#CTL2
!(endsWith($in.0.file_url,".fmt") or endsWith($in.0.file_url,".wjob"))]]></attr>
</Node>
<Node guiName="not Null" guiX="1520" guiY="375" id="NOT_NULL" type="EXT_FILTER">
<attr name="filterExpression"><![CDATA[//#CTL2
$in.0.redacted_properties != null or  $in.0.name != null or $in.0.type != null]]></attr>
</Node>
<Node guiName="Partition" guiX="295" guiY="500" id="PARTITION" type="PARTITION">
<attr name="partitionSource"><![CDATA[//#CTL2
// This transformation partitions input records into multiple output ports.

// Returns the number of the output port where the input record will be sent.
function integer getOutputPort() {
	return ${FILE_TYPE_PORT};
	
}

// Called during component initialization, partitionCount is the number of output ports.
// function void init(integer partitionCount) {}

// Called during each graph run before the transform is executed. May be used to allocate and initialize resources.
// All resources allocated within this method should be released by the postExecute() method.
// function void preExecute() {}

// Called only if getOutputPort() throws an exception.
// function integer getOutputPortOnError(string errorMessage, string stackTrace) {
// }

// Called during each graph run after the entire transform was executed. Should be used to free any resources
// allocated within the preExecute() method.
// function void postExecute() {}

// Called to return a user-defined error message when an error occurs.
// function string getMessage() {}
]]></attr>
</Node>
<Node guiName="REDACTED" guiX="1670" guiY="375" id="REDACTED" type="EXT_FILTER">
<attr name="filterExpression"><![CDATA[//#CTL2
$in.0.status == "REDACTED"]]></attr>
</Node>
<Node guiName="rejoin lines" guiX="1545" guiY="50" id="REJOIN_LINES" key="fileURL(a)" type="DENORMALIZER">
<attr name="denormalize"><![CDATA[//#CTL2
// This transformation defines the way in which multiple input records 
// (with the same key) are denormalized into one output record. 

// This function is called for each input record from a group of records
// with the same key.
string[] lineContent;
function integer append() {
	append(lineContent,$in.0.fileContent);
	return OK;
}

// This function is called once after the append() function was called for all records
// of a group of input records defined by the key.
// It creates a single output record for the whole group.
function integer transform() {
	$out.0.fileContent = join("\n",lineContent);
	$out.0.fileURL = $in.0.fileURL;
	return OK;
}

// Called during component initialization.
// function boolean init() {}

// Called during each graph run before the transform is executed. May be used to allocate and initialize resources
// required by the transform. All resources allocated within this method should be released
// by the postExecute() method.
// function void preExecute() {}

// Called only if append() throws an exception.
// function integer appendOnError(string errorMessage, string stackTrace) {
// }

// Called only if transform() throws an exception.
//function integer transformOnError(string errorMessage, string stackTrace) {
//}

// Called after transform() to return the resources that have been used to their initial state
// so that next group of records with different key may be parsed.
// function void clean() {}

// Called during each graph run after the entire transform was executed. Should be used to free any resources
// allocated within the preExecute() method.
// function void postExecute() {}

// Called to return a user-defined error message when an error occurs.
// function string getMessage() {}
]]></attr>
</Node>
<Node guiName="sanitize .cfg" guiX="670" guiY="450" id="SANITIZE_CFG1" type="REFORMAT">
<attr name="transform"><![CDATA[//#CTL2

// Transforms input record into output record.

function integer transform() {
	string lineContent = $in.0.lineContent;
	string originalLineContent = $in.0.lineContent;	

	

	//logic here for altering fileContent based on need for sanitization
	if (contains(lineContent,'name=')){
		string[] findConnName= find(lineContent,'name=[^"]*');
		string connName = replace(findConnName[0],"name=","");
		dictionary.connectionName = connName;
	}


//CONNECTIONS

			
	//Sanitize Properties of connections
	string[] editedProperties;
	if (contains(lowerCase(lineContent),"dburl")){
		if(!contains(lowerCase(lineContent),'dburl=${')and !contains(lowerCase(lineContent),"simplehttpapi")) {
			if(!contains(lowerCase(lineContent),"user=${")){lineContent = replace(lineContent,"(?i)user=[^;,&?]+","user=*****");}
			if(!contains(lowerCase(lineContent),"username=${")){lineContent = replace(lineContent,"(?i)username=[^;,&?]+","username=*****");}
			if(!contains(lowerCase(lineContent),"password=${")){lineContent = replace(lineContent,"(?i)password=[^;,&?]+","password=*****");}
			
			//Account for Oracle, which doesn't use the same conventions
			if(contains(lineContent,"oracle")){
			integer start = indexOf(lineContent,"oracle") +6;
			integer finish = length(lineContent)-indexOf(lineContent,"@");
			lineContent = concat(left(lineContent,start),"*****",right(lineContent,finish));
			}
			
			
			if (originalLineContent != lineContent and not in("dbURL",editedProperties)){append(editedProperties,"dbURL");}
		}	
	}
	//all other properties besides dbURL	
	else{			
		foreach(string property:$in.0.propertiesList){
			string propertyREGEX = concat(property,'=[^"]*');
			string propertyREDACTED = concat(property,'=******');
				
				if(contains(lineContent,property+ '=') and !contains(lineContent,property+ '=${')and !contains(lowerCase(lineContent),"simplehttpapi")) {
							
					//keep first up to "//" if URL
					if(endsWith(lowerCase(property),"url")){
						string[] findREGEX = find(lineContent,propertyREGEX);
						string urlValue = "";
						if (length(findREGEX) > 0){urlValue = findREGEX[0];} 
						urlValue = replace(urlValue, property+"=","");
						urlValue = replace(urlValue,'["(){}$#\\]',"");
						if(contains(urlValue,"//")){urlValue = split(urlValue,"//")[0] + "//****";}
						else {urlValue = "*******";}
						
						//currently we are not redacting simpleHttpApi but the below code is there if that changes again
						//if(contains(lowerCase(lineContent),"simplehttpapi")){urlValue = concat(urlValue,"simpleHttpApi");}				
						propertyREDACTED = concat(property,'="',urlValue,'"');
					}
					
					lineContent = replace(lineContent,propertyREGEX,propertyREDACTED);
					if (originalLineContent != lineContent){append(editedProperties,property);}
				}
		}			
	}
	
	if(length(editedProperties) > 0){
		$out.1.type = "connection";
		$out.1.redacted_properties = join(",",editedProperties);
		dictionary.status = "REDACTED";
	}	
	



	
//OUTPUT
	$out.0.fileContent = nvl(lineContent,"");
	$out.0.fileURL = $in.0.fileURL;
	
	//Prepare Sanitization Report
	if(lineContent != originalLineContent) {dictionary.status = "REDACTED";}
	$out.1.status = dictionary.status;
	$out.1.sandbox = getParamValue("SANDBOX_NAME");
	$out.1.file_url = $in.0.fileURL;
	$out.1.file_name = getParamValue("FILE_NAME");
	if($out.1.status == "REDACTED") {$out.1.message = "Potentially sensitive data";}
	return ALL;
}

// Called during component initialization.
// function boolean init() {}

// Called during each graph run before the transform is executed. May be used to allocate and initialize resources
// required by the transform. All resources allocated within this method should be released
// by the postExecute() method.
// function void preExecute() {}

// Called only if transform() throws an exception.
// function integer transformOnError(string errorMessage, string stackTrace) {}

// Called during each graph run after the entire transform was executed. Should be used to free any resources
// allocated within the preExecute() method.
// function void postExecute() {}

// Called to return a user-defined error message when an error occurs.
// function string getMessage() {}
]]></attr>
</Node>
<Node guiName="sanitize graph subgraph jobflow" guiX="670" guiY="625" id="SANITIZE_GRAPH_SUBGRAPH_JOBFLOW" type="REFORMAT">
<attr name="transform"><![CDATA[//#CTL2

// Transforms input record into output record.
string component;
string parameter;
string connection;
boolean isGraphParameter = false;
boolean isConnection = false;
boolean isComponent = false;


function integer transform() {
	string lineContent = $in.0.lineContent;
	string originalLineContent = $in.0.lineContent;	
	if (startsWith(lineContent,'<GraphParameter')) {isGraphParameter = true; isConnection = false; isComponent = false;}
	if (startsWith(lineContent,'<Connection')) {isGraphParameter = false; isConnection = true; isComponent = false;}
	if (startsWith(lineContent,'<Node')) {isGraphParameter = false; isConnection = false; isComponent = true;}
	

	//logic here for altering fileContent based on need for sanitization


//PARAMETERS
	if (isGraphParameter){
		if(startsWith(lineContent,'<GraphParameter ') and !(contains(lineContent,'value="$') or contains(lineContent,'name="PROJECT"') or contains(lineContent,'secure="true"')))  {
			lineContent = replace(lineContent,'(?i)value="[^"]*"','value="******"');
			
			string[] findParamName= find(lineContent,'name="[^"]*"');
			parameter = replace(findParamName[0],"name=","");
			parameter = replace(parameter,'"',"");
			
			$out.1.type = "parameter";
			$out.1.name = parameter;
			$out.1.redacted_properties = "value";
			dictionary.status = "REDACTED";
			;
		}
	}	

//CONNECTIONS
	if (isConnection){
		if (startsWith(lineContent,'<Connection')){
			string[] findId = find(lineContent,'id="[^"]*"');
			connection = replace(findId[0],"id=","");
			connection = replace(connection,'"',"");
			
			
			
			
			
		//Sanitize Properties of connections
			string[] editedProperties;
			
			//Need to handle dbURL differently from other properties
			if (contains(lineContent,'dbURL="')){
				if(!contains(lowerCase(lineContent),'dburl=${')and !contains(lowerCase(lineContent),"simplehttpapi")) {
					string dbURL = find(lineContent,'dbURL="[^"]*"')[0];
					if(!contains(lowerCase(lineContent),"user=${")){dbURL = replace(dbURL,'(?i)user=[^;,&?"]+',"user=*****");}
					if(!contains(lowerCase(lineContent),"username=${")){dbURL = replace(dbURL,'(?i)username=[^;,&?"]+',"username=*****");}
					if(!contains(lowerCase(lineContent),"password=${")){dbURL = replace(dbURL,'(?i)password=[^;,&?"]+',"password=*****");}
					lineContent = replace(lineContent,'dbURL="[^"]*"',dbURL);
					
					//Account for Oracle, which doesn't use the same conventions
					if(contains(lineContent,"oracle")){
						integer start = indexOf(lineContent,"oracle") +6;
						integer finish = length(lineContent)-indexOf(lineContent,"@");
						lineContent = concat(left(lineContent,start),"*****",right(lineContent,finish));
					}
					
			
					if (originalLineContent != lineContent and !in("dbURL",editedProperties)){append(editedProperties,"dbURL");}
				}	
				
				
			}
			//all other properties besides dbURL						
			foreach(string property:$in.0.propertiesList){
				string propertyREGEX = concat(property,'="[^"]*"');
				string propertyREDACTED = concat(property,'="******"');
			
				if(contains(lineContent,property+ '=') and !contains(lineContent,property+ '="${')and !contains(lowerCase(lineContent),"simplehttpapi")) {
						
					//keep first up to "//" if URL
					if(endsWith(lowerCase(property),"url")){
						string[] findREGEX = find(lineContent,propertyREGEX);
						string urlValue = "";
						if (length(findREGEX) > 0){urlValue = findREGEX[0];} 
						urlValue = replace(urlValue, property+"=","");
						urlValue = replace(urlValue,'["(){}$#\\]',"");
						if(contains(urlValue,"//")){urlValue = split(urlValue,"//")[0] + "//****";}
						else {urlValue = "*******";}
					
						//currently we are not redacting simpleHttpApi but the below code is there if that changes again
						//if(contains(lowerCase(lineContent),"simplehttpapi")){urlValue = concat(urlValue,"simpleHttpApi");}				
						propertyREDACTED = concat(property,'="',urlValue,'"');
					}
					
					lineContent = replace(lineContent,propertyREGEX,propertyREDACTED);
					if (originalLineContent != lineContent){append(editedProperties,property);}
				}
			}			
			if(length(editedProperties) > 0){
				$out.1.type = "connection";
				$out.1.name = connection;
				$out.1.redacted_properties = join(",",editedProperties);
				dictionary.status = "REDACTED";
			}	
		}	
	}	

//COMPONENT PROPERTIES

	if (isComponent){
		//identify Component
		if (startsWith(lineContent,'<Node ')){
			string[] findId = find(lineContent,'id="[^"]*"');
			component = replace(findId[0],"id=","");
			component = replace(component,'"',"");
			
		//Sanitize Properties of components
			string[] editedProperties;
			
			//Need to handle dbURL differently from other properties
			if (contains(lineContent,'dbURL="')){
				if(!contains(lowerCase(lineContent),'dburl=${')and !contains(lowerCase(lineContent),"simplehttpapi")) {
					string dbURL = find(lineContent,'dbURL="[^"]*"')[0];
					if(!contains(lowerCase(lineContent),"user=${")){dbURL = replace(dbURL,"(?i)user=[^;,&?]+","user=*****");}
					if(!contains(lowerCase(lineContent),"username=${")){dbURL = replace(dbURL,"(?i)username=[^;,&?]+","username=*****");}
					if(!contains(lowerCase(lineContent),"password=${")){dbURL = replace(dbURL,"(?i)password=[^;,&?]+","password=*****");}
					lineContent = replace(lineContent,'dbURL="[^"]*"',dbURL +'"');
					if (originalLineContent != lineContent and !in("dbURL",editedProperties)){append(editedProperties,"dbURL");}
				}	
				//Account for Oracle, which doesn't use the same conventions
				if(contains(lineContent,"oracle")){
					integer start = indexOf(lineContent,"oracle") +6;
					integer finish = length(lineContent)-indexOf(lineContent,"@");
					lineContent = concat(left(lineContent,start),"*****",right(lineContent,finish));
				}
			}				
			
			//all other properties besides dbURL	
			foreach(string property:$in.0.propertiesList){
				string propertyREGEX = concat(property,'="[^"]*"');
				string propertyREDACTED = concat(property,'="******"');
				
				
				if(contains(lineContent,property+ '=') and !contains(lineContent,property+ '="${')and !contains(lowerCase(lineContent),"simplehttpapi")) {
					
					//keep first up to "//" if URL
					if(endsWith(lowerCase(property),"url")){
						string[] findREGEX = find(lineContent,propertyREGEX);
						string urlValue = "";
						if (length(findREGEX) > 0){urlValue = findREGEX[0];} 
						urlValue = replace(urlValue, property+"=","");
						urlValue = replace(urlValue,'["(){}$#\\]',"");
						if(contains(urlValue,"//")){urlValue = split(urlValue,"//")[0] + "//****";}
						else {urlValue = "*******";}
						
						//currently we are not redacting simpleHttpApi but the below code is there if that changes again
						//if(contains(lowerCase(lineContent),"simplehttpapi")){urlValue = concat(urlValue,"simpleHttpApi");}
						propertyREDACTED = concat(property,'="',urlValue,'"');
					}
					
					lineContent = replace(lineContent,propertyREGEX,propertyREDACTED);
					if (originalLineContent != lineContent){append(editedProperties,property);}
				}		
			}
			if(length(editedProperties) > 0){
				$out.1.type = "component";
				$out.1.name = component;
				$out.1.redacted_properties = join(",",editedProperties);
			}
		}		
	}
		

	
//OUTPUT
	$out.0.fileContent = nvl(lineContent,"");
	$out.0.fileURL = $in.0.fileURL;
	
	//Prepare Sanitization Report
	if(lineContent != originalLineContent) {dictionary.status = "REDACTED";}
	$out.1.status = dictionary.status;
	$out.1.sandbox = getParamValue("SANDBOX_NAME");
	$out.1.file_url = $in.0.fileURL;
	$out.1.file_name = getParamValue("FILE_NAME");
	if($out.1.status == "REDACTED") {$out.1.message = "Potentially sensitive data";}
	return ALL;
}

// Called during component initialization.
// function boolean init() {}

// Called during each graph run before the transform is executed. May be used to allocate and initialize resources
// required by the transform. All resources allocated within this method should be released
// by the postExecute() method.
// function void preExecute() {}

// Called only if transform() throws an exception.
// function integer transformOnError(string errorMessage, string stackTrace) {}

// Called during each graph run after the entire transform was executed. Should be used to free any resources
// allocated within the preExecute() method.
// function void postExecute() {}

// Called to return a user-defined error message when an error occurs.
// function string getMessage() {}
]]></attr>
</Node>
<Node guiName="sanitize .prm" guiX="670" guiY="275" id="SANITIZE_PRM" type="REFORMAT">
<attr name="transform"><![CDATA[//#CTL2

// Transforms input record into output record.
string parameter;
function integer transform() {
	string lineContent = $in.0.lineContent;
	string originalLineContent = $in.0.lineContent;
	//logic here for altering fileContent based on need for sanitization
	
	//PARAMETERS
	if(startsWith(lineContent,'<GraphParameter ') and contains(lineContent,'value=') and !(contains(lineContent,'value="$') or contains(lineContent,'name="PROJECT"') or contains(lineContent,'secure="true"')))  {
			lineContent = replace(lineContent,'(?i)value="[^"]*"','value="******"');
			
			string[] findParamName= find(lineContent,'name="[^"]*"');
			parameter = replace(findParamName[0],"name=","");
			parameter = replace(parameter,'"',"");
			
			$out.1.type = "parameter";
			$out.1.name = parameter;
			$out.1.redacted_properties = "value";
			dictionary.status = "REDACTED";
			;
		}
		
	
//OUTPUT
	$out.0.fileContent = nvl(lineContent,"");
	$out.0.fileURL = $in.0.fileURL;
	
	//Prepare Sanitization Report
	if(lineContent != originalLineContent) {dictionary.status = "REDACTED";}
	$out.1.status = dictionary.status;
	$out.1.sandbox = getParamValue("SANDBOX_NAME");
	$out.1.file_url = $in.0.fileURL;
	$out.1.file_name = getParamValue("FILE_NAME");
	if($out.1.status == "REDACTED") {$out.1.message = "Potentially sensitive data";}
	return ALL;
}

// Called during component initialization.
// function boolean init() {}

// Called during each graph run before the transform is executed. May be used to allocate and initialize resources
// required by the transform. All resources allocated within this method should be released
// by the postExecute() method.
// function void preExecute() {}

// Called only if transform() throws an exception.
// function integer transformOnError(string errorMessage, string stackTrace) {}

// Called during each graph run after the entire transform was executed. Should be used to free any resources
// allocated within the preExecute() method.
// function void postExecute() {}

// Called to return a user-defined error message when an error occurs.
// function string getMessage() {}
]]></attr>
</Node>
<Node guiName="SimpleCopy" guiX="845" guiY="350" id="SIMPLE_COPY" type="SIMPLE_COPY"/>
<Node guiName="SimpleGather" guiX="1370" guiY="50" id="SIMPLE_GATHER" type="SIMPLE_GATHER"/>
<Node guiName="SimpleGather" guiX="1370" guiY="375" id="SIMPLE_GATHER1" type="SIMPLE_GATHER"/>
<Node guiName="SimpleGather" guiX="1120" guiY="1025" id="SIMPLE_GATHER3" type="SIMPLE_GATHER"/>
<Node guiName="wrangler files" guiX="670" guiY="750" id="WRANGLER_FILES" type="REFORMAT">
<attr name="transform"><![CDATA[//#CTL2

// Transforms input record into output record.
function integer transform() {
	$out.0.fileContent = nvl($in.0.lineContent,"");
	$out.0.fileURL = $in.0.fileURL;
	$out.1.file_url = $in.0.fileURL;
	$out.1.sandbox = getParamValue("SANDBOX_NAME");
	$out.1.file_name = getParamValue("FILE_NAME");
	$out.1.message = "This file type can't be redacted automatically and might contain sensitive data. Please check the file and manually remove content you don't want to share.";
	dictionary.status = "REQUIRES ATTENTION - FILE NOT SUPPORTED";
	$out.1.status = dictionary.status;
	return ALL;
}

// Called during component initialization.
// function boolean init() {}

// Called during each graph run before the transform is executed. May be used to allocate and initialize resources
// required by the transform. All resources allocated within this method should be released
// by the postExecute() method.
// function void preExecute() {}

// Called only if transform() throws an exception.
// function integer transformOnError(string errorMessage, string stackTrace) {}

// Called during each graph run after the entire transform was executed. Should be used to free any resources
// allocated within the preExecute() method.
// function void postExecute() {}

// Called to return a user-defined error message when an error occurs.
// function string getMessage() {}
]]></attr>
</Node>
<Node guiName="write JNDI message" guiX="1695" guiY="1375" id="WRITE_JNDI_MESSAGE" type="REFORMAT">
<attr name="transform"><![CDATA[//#CTL2

// Transforms input record into output record.
function integer transform() {
	$out.0.file_url = $in.0.fileURL;
	$out.0.sandbox = getParamValue("SANDBOX_NAME");
	$out.0.file_name = getParamValue("FILE_NAME");
	dictionary.status = "REQUIRES ATTENTION - JNDI DETECTED";
	$out.0.message = "Please include the JNDI connection details configured on the Server as JNDI connections are defined outside the sandbox.";
	$out.0.status = dictionary.status;
	return ALL;
}

// Called during component initialization.
// function boolean init() {}

// Called during each graph run before the transform is executed. May be used to allocate and initialize resources
// required by the transform. All resources allocated within this method should be released
// by the postExecute() method.
// function void preExecute() {}

// Called only if transform() throws an exception.
// function integer transformOnError(string errorMessage, string stackTrace) {}

// Called during each graph run after the entire transform was executed. Should be used to free any resources
// allocated within the preExecute() method.
// function void postExecute() {}

// Called to return a user-defined error message when an error occurs.
// function string getMessage() {}
]]></attr>
</Node>
<Node dedupKey="file_url(a)" guiName="1 log per file" guiX="1620" guiY="1025" id="_1_LOG_PER_FILE" type="DEDUP"/>
<Node guiName="1 per file" guiX="1545" guiY="1375" id="_1_PER_FILE" type="DEDUP"/>
<Edge fromNode="ADD_TO_HELP_EARLIER_CLOVER_VERSIONS:0" guiBendpoints="" guiRouter="Manhattan" id="Edge35" inPort="Port 0 (in)" metadata="Metadata4" outPort="Port 0 (out)" toNode="WRITE_SANITIZED_FILES:0"/>
<Edge fromNode="CHECK_FOR_JNDI:0" guiBendpoints="" guiRouter="Manhattan" id="Edge38" inPort="Port 0 (in)" outPort="Port 0 (accepted)" toNode="_1_PER_FILE:0"/>
<Edge fromNode="COMBINE_CFG_PROPERTIES:0" guiBendpoints="" guiRouter="Manhattan" id="Edge6" inPort="Port 1 (in)" metadata="Metadata8" outPort="Port 0 (out)" toNode="SIMPLE_GATHER1:1"/>
<Edge fromNode="FILES_NOT_SANITIZED1:0" guiBendpoints="" guiRouter="Manhattan" id="Edge36" inPort="Port 4 (in)" outPort="Port 0 (out)" toNode="SIMPLE_GATHER:4"/>
<Edge fromNode="FILES_NOT_SANITIZED1:1" guiBendpoints="" guiRouter="Manhattan" id="Edge28" inPort="Port 0 (in)" outPort="Port 1 (out)" toNode="SIMPLE_GATHER3:0"/>
<Edge fromNode="GENERAL_ERROR_MESSAGE:0" guiBendpoints="" guiRouter="Manhattan" id="Edge3" inPort="Port 2 (in)" metadata="Metadata8" outPort="Port 0 (out)" toNode="SIMPLE_GATHER2:2"/>
<Edge fromNode="IGNORE_FMT_AND_WJOB:0" guiBendpoints="" guiRouter="Manhattan" id="Edge30" inPort="Port 0 (in)" outPort="Port 0 (accepted)" toNode="_1_LOG_PER_FILE:0"/>
<Edge fromNode="NOT_NULL:0" guiBendpoints="" guiRouter="Manhattan" id="Edge17" inPort="Port 0 (in)" outPort="Port 0 (accepted)" toNode="REDACTED:0"/>
<Edge fromNode="PARTITION:0" guiBendpoints="" guiRouter="Manhattan" id="Edge7" inPort="Port 0 (in)" outPort="Port 0 (out)" toNode="SANITIZE_PRM:0"/>
<Edge fromNode="PARTITION:1" guiBendpoints="" guiRouter="Manhattan" id="Edge8" inPort="Port 0 (in)" outPort="Port 1 (out)" toNode="SANITIZE_CFG1:0"/>
<Edge fromNode="PARTITION:2" guiBendpoints="" guiRouter="Manhattan" id="Edge9" inPort="Port 0 (in)" outPort="Port 2 (out)" toNode="SANITIZE_GRAPH_SUBGRAPH_JOBFLOW:0"/>
<Edge fromNode="PARTITION:3" guiBendpoints="" guiRouter="Manhattan" id="Edge25" inPort="Port 0 (in)" outPort="Port 3 (out)" toNode="WRANGLER_FILES:0"/>
<Edge fromNode="PARTITION:4" guiBendpoints="" guiRouter="Manhattan" id="Edge27" inPort="Port 0 (in)" outPort="Port 4 (out)" toNode="FILES_NOT_SANITIZED1:0"/>
<Edge fromNode="REDACTED:0" guiBendpoints="" guiRouter="Manhattan" id="Edge23" inPort="Port 0 (in)" outPort="Port 0 (accepted)" toNode="SIMPLE_GATHER2:0"/>
<Edge fromNode="REDACTED:1" guiBendpoints="" guiRouter="Manhattan" id="Edge24" inPort="Port 0 (in)" outPort="Port 1 (rejected)" toNode="GENERAL_ERROR_MESSAGE:0"/>
<Edge fromNode="REJOIN_LINES:0" guiBendpoints="" guiRouter="Manhattan" id="Edge2" inPort="Port 0 (in)" metadata="Metadata4" outPort="Port 0 (out)" toNode="ADD_TO_HELP_EARLIER_CLOVER_VERSIONS:0"/>
<Edge fromNode="SANITIZE_CFG1:0" guiBendpoints="" guiRouter="Manhattan" id="Edge10" inPort="Port 0 (in)" outPort="Port 0 (out)" toNode="SIMPLE_COPY:0"/>
<Edge fromNode="SANITIZE_CFG1:1" guiBendpoints="" guiRouter="Manhattan" id="Edge19" inPort="Port 0 (in)" metadata="Metadata8" outPort="Port 1 (out)" toNode="COMBINE_CFG_PROPERTIES:0"/>
<Edge fromNode="SANITIZE_GRAPH_SUBGRAPH_JOBFLOW:0" guiBendpoints="" guiRouter="Manhattan" id="Edge11" inPort="Port 2 (in)" outPort="Port 0 (out)" toNode="SIMPLE_GATHER:2"/>
<Edge fromNode="SANITIZE_GRAPH_SUBGRAPH_JOBFLOW:1" guiBendpoints="" guiRouter="Manhattan" id="Edge14" inPort="Port 2 (in)" metadata="Metadata8" outPort="Port 1 (out)" toNode="SIMPLE_GATHER1:2"/>
<Edge fromNode="SANITIZE_PRM:0" guiBendpoints="" guiRouter="Manhattan" id="Edge0" inPort="Port 0 (in)" metadata="Metadata4" outPort="Port 0 (out)" toNode="SIMPLE_GATHER:0"/>
<Edge fromNode="SANITIZE_PRM:1" guiBendpoints="" guiRouter="Manhattan" id="Edge18" inPort="Port 0 (in)" outPort="Port 1 (out)" toNode="SIMPLE_GATHER1:0"/>
<Edge fromNode="SIMPLE_COPY:0" guiBendpoints="" guiRouter="Manhattan" id="Edge15" inPort="Port 1 (in)" outPort="Port 0 (out)" toNode="SIMPLE_GATHER:1"/>
<Edge fromNode="SIMPLE_COPY:1" guiBendpoints="" guiRouter="Manhattan" id="Edge37" inPort="Port 0 (in)" outPort="Port 1 (out)" toNode="CHECK_FOR_JNDI:0"/>
<Edge fromNode="SIMPLE_GATHER:0" guiBendpoints="" guiRouter="Manhattan" id="Edge4" inPort="Port 0 (in)" outPort="Port 0 (out)" toNode="REJOIN_LINES:0"/>
<Edge fromNode="SIMPLE_GATHER1:0" guiBendpoints="" guiRouter="Manhattan" id="Edge16" inPort="Port 0 (in)" outPort="Port 0 (out)" toNode="NOT_NULL:0"/>
<Edge fromNode="SIMPLE_GATHER3:0" guiBendpoints="" guiRouter="Manhattan" id="Edge42" inPort="Port 0 (in)" outPort="Port 0 (out)" toNode="IGNORE_FMT_AND_WJOB:0"/>
<Edge fromNode="WRANGLER_FILES:0" guiBendpoints="" guiRouter="Manhattan" id="Edge26" inPort="Port 3 (in)" outPort="Port 0 (out)" toNode="SIMPLE_GATHER:3"/>
<Edge fromNode="WRANGLER_FILES:1" guiBendpoints="" guiRouter="Manhattan" id="Edge43" inPort="Port 1 (in)" outPort="Port 1 (out)" toNode="SIMPLE_GATHER3:1"/>
<Edge fromNode="WRITE_JNDI_MESSAGE:0" guiBendpoints="" guiRouter="Manhattan" id="Edge39" inPort="Port 5 (in)" metadata="Metadata8" outPort="Port 0 (out)" toNode="SIMPLE_GATHER2:5"/>
<Edge fromNode="_1_LOG_PER_FILE:0" guiBendpoints="" guiRouter="Manhattan" id="Edge29" inPort="Port 3 (in)" outPort="Port 0 (unique)" toNode="SIMPLE_GATHER2:3"/>
<Edge fromNode="_1_PER_FILE:0" guiBendpoints="" guiRouter="Manhattan" id="Edge40" inPort="Port 0 (in)" outPort="Port 0 (unique)" toNode="WRITE_JNDI_MESSAGE:0"/>
</Phase>
<Phase number="4">
<Node excludeFields="fileURL" fileURL="zip:(${DATATMP_DIR}/Sanitized.zip)#" guiName="write sanitized files" guiX="2345" guiY="50" id="WRITE_SANITIZED_FILES" makeDirs="true" outputFieldNames="false" partitionFileTag="keyNameFileTag" partitionKey="fileURL" type="FLAT_FILE_WRITER"/>
</Phase>
<Phase number="9">
<Node guiName="GetJobInput" guiX="1370" guiY="650" id="GET_JOB_INPUT1" type="GET_JOB_INPUT">
<attr name="mapping"><![CDATA[//#CTL2

// Transforms input record into output record.
function integer transform() {
	$out.0.file_url = $in.0.fileURL;
	$out.0.sandbox = getParamValue("SANDBOX_NAME");
	$out.0.file_name = getParamValue("FILE_NAME");
	$out.0.status = $in.0.status;
	$out.0.message = "No sensitive data detected.";
	return ALL;
}

// Called during component initialization.
// function boolean init() {}

// Called during each graph run before the transform is executed. May be used to allocate and initialize resources
// required by the transform. All resources allocated within this method should be released
// by the postExecute() method.
// function void preExecute() {}

// Called only if transform() throws an exception.
// function integer transformOnError(string errorMessage, string stackTrace) {}

// Called during each graph run after the entire transform was executed. Should be used to free any resources
// allocated within the preExecute() method.
// function void postExecute() {}

// Called to return a user-defined error message when an error occurs.
// function string getMessage() {}
]]></attr>
</Node>
<Node guiName="UNREDACTED" guiX="1520" guiY="650" id="UNREDACTED" type="EXT_FILTER">
<attr name="filterExpression"><![CDATA[//#CTL2
$in.0.status == "UNREDACTED"]]></attr>
</Node>
<Edge fromNode="GET_JOB_INPUT1:0" guiBendpoints="" guiRouter="Manhattan" id="Edge21" inPort="Port 0 (in)" outPort="Port 0 (out)" toNode="UNREDACTED:0"/>
<Edge fromNode="UNREDACTED:0" guiBendpoints="" guiRouter="Manhattan" id="Edge22" inPort="Port 1 (in)" outPort="Port 0 (accepted)" toNode="SIMPLE_GATHER2:1"/>
</Phase>
<Phase number="10">
<Node append="true" fileURL="${DATATMP_DIR}/${SANDBOX_NAME}_edits/${RUN_ID}.csv" guiName="save lines to temp file" guiX="2270" guiY="700" id="SAVE_LINES_TO_TEMP_FILE" makeDirs="true" type="FLAT_FILE_WRITER"/>
<Node guiName="SimpleGather" guiX="2095" guiY="700" id="SIMPLE_GATHER2" type="SIMPLE_GATHER"/>
<Edge fromNode="SIMPLE_GATHER2:0" guiBendpoints="" guiRouter="Manhattan" id="Edge20" inPort="Port 0 (in)" outPort="Port 0 (out)" toNode="SAVE_LINES_TO_TEMP_FILE:0"/>
</Phase>
</Graph>
